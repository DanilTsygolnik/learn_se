# Часть 2

Разбираемся с языком ДРАКОН

## Глава 4

ДРАКОН - это про сверхпонятное описание алгоритмов

уже в начале описания алгоритма используются ключевые 
Отличное подспорье при составлении спецификации -- понимание задачи начинает формироваться на первом этапе, при ответе на 3 царских вопроса:
- что за задачу решаем? -- емкое название алгоритма в заголовке
- из каких подзадач состоит задача? -- выделяем модули, "ветки", которые должны описываться одной фразой
- располагаем "ветки" (модули) в логическом порядке, таким образом полность описывая алгоритм

внутренние соединители нежелательны -- нарушается линейная, понятная структура алгоритма (структурное программирование, привет)


Проще показать, чем написать -- рис. 22 прямо хорош. рис. 25 по рыболке - в дополнение

Выжимка главных правил оформления схем -- 4.15

# Главы 5-6

"Примитив" - логический блок, описывающий одну элементарную процедуру (описывается не более чем 10 иконами).

"Силуэт" - это конструкция из нескольких блоков (один блок - одна "ветка"). 

Алгоритм разбиватется на логические блоки, "ветки", которые организованы в связанную логическую структуру).

Для практики - правила из выводов к каждой главе

# Глава 7

Эквивалентные алгоритмы - алгоритмы, дающие один и тот же результат при одинаковых входных данных.

Выпрямление маршрутов через рокировки + правильная организация маршрутов в соотв. с принципами гл. 5-6 -- гл. 11, рис. 48-51

Шампур и порядок маршрутов (слева направо) - главные. Кол-во вертикалей вторично.

Никаких пересечений, пускай и с большим числом веток в схеме-силуэте -- гл. 7.19

Еще одни способ сделать схему эргономичный (первый - сделать из "примитива" "силуэт" с помощью "ветвей") - использовать "вставку" (еще одно проявление инкапсуляции??).       
Движение вверх в ДРАКОНЕ запрещено (рис. 69), поэтому иконы можно группировать в отдельные логические блоки, которые на схеме-силуэте или схеме-примитиве изображаются всего одной - "вставкой"

Преобразование с помощью "вставки" осуществляется через операцию подстановки, что есть эквивалентное преобразование алгоритмов (гл. 7.21).
